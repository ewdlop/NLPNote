# 數學證明其運行複雜度

在計算機科學與邏輯學中，「數學證明」可從兩個角度來考慮其運行複雜度：**證明檢查**（Proof Checking）與**證明搜索／自動定理證明**（Proof Search／ATP）。以下分別說明：

## 1. 證明檢查（Proof Checking）

### 1.1 定義與基本概念

**證明檢查**是指給定一個形式化的證明（即一系列運用了正確推理規則的公式序列），檢查每一步推理是否符合系統規則的過程。

形式化地，設 $\mathcal{S}$ 為一個證明系統，$\varphi$ 為待證明的公式，$\pi = \langle \psi_1, \psi_2, \ldots, \psi_n \rangle$ 為一個證明序列，其中 $\psi_n = \varphi$。證明檢查問題是：

**輸入**: 證明系統 $\mathcal{S}$，公式 $\varphi$，證明候選 $\pi$  
**問題**: 判斷 $\pi$ 是否為 $\varphi$ 在 $\mathcal{S}$ 中的有效證明

### 1.2 複雜度分析

在常見的證明系統中，證明檢查的複雜度主要取決於：

1. **推理規則的驗證複雜度**: 每條推理規則的檢查時間
2. **證明長度**: 證明序列 $\pi$ 的長度 $|\pi|$

**定理 1.1**: 在大多數標準證明系統（如自然演繹、序列演算、分辨定理等）中，若每條推理規則的驗證可在常數或多項式時間內完成，則整體證明檢查時間為 $O(|\pi|)$ 或 $O(|\pi|^k)$，其中 $k$ 為常數。

**證明**: 設證明 $\pi = \langle \psi_1, \psi_2, \ldots, \psi_n \rangle$，對每個 $\psi_i$，需檢查其是否由前面的公式通過某條推理規則得出。若每次檢查的時間為 $O(f(i))$，則總時間為：

$$T(\pi) = \sum_{i=1}^{n} O(f(i))$$

當 $f(i) = O(1)$ 時，$T(\pi) = O(n) = O(|\pi|)$；當 $f(i) = O(i^{k-1})$ 時，$T(\pi) = O(n^k) = O(|\pi|^k)$。 □

### 1.3 實際系統中的證明檢查

**Coq 型別檢查**: 在 Coq 證明助理中，證明實際上是型別正確的項（term），證明檢查等價於型別檢查。根據 [MathOverflow 討論](https://mathoverflow.net/questions/226966/algorithmic-complexity-of-formal-proof-verification)，Coq 的型別檢查算法在最壞情況下具有線性或準線性的時間複雜度。

**形式化**: 設 $t$ 為一個 λ-項，$\Gamma$ 為型別環境，$\tau$ 為目標型別。型別檢查問題為：

$$\text{TypeCheck}(\Gamma, t, \tau) \stackrel{?}{\Longleftrightarrow} \Gamma \vdash t : \tau$$

在 Calculus of Constructions 中，此問題的複雜度為 $O(|t| \cdot \log|t|)$。

## 2. 命題邏輯的證明搜索

### 2.1 問題定義

**命題邏輯永真性問題**（Propositional Tautology Problem, TAUT）：
- **輸入**: 命題邏輯公式 $\varphi$
- **問題**: 判斷 $\varphi$ 是否為永真式（tautology）

此問題等價於 SAT 問題的補問題，即：
$$\varphi \text{ 是永真式} \Leftrightarrow \neg\varphi \text{ 不可滿足}$$

### 2.2 複雜度理論結果

**定理 2.1**: TAUT 是 coNP-complete 的。

**證明**: 
1. **TAUT ∈ coNP**: 若 $\varphi$ 不是永真式，則存在一個賦值使 $\varphi$ 為假，此賦值可作為多項式長度的證據。
2. **coNP-hard**: 通過從 SAT 問題的歸約，由於 SAT 是 NP-complete 的，其補問題 co-SAT ≡ TAUT 是 coNP-complete 的。 □

### 2.3 證明系統的複雜度

設 $\mathcal{P}$ 為一個命題證明系統，對永真式 $\varphi$，定義：

$$s_\mathcal{P}(\varphi) = \min\{|\pi| : \pi \text{ 是 } \varphi \text{ 在 } \mathcal{P} \text{ 中的證明}\}$$

**定理 2.2**: 對於大多數已知的命題證明系統（Resolution、Frege 系統、Extended Frege 等），存在永真式家族 $\{\varphi_n\}_{n \geq 1}$ 使得 $s_\mathcal{P}(\varphi_n) = 2^{\Omega(n)}$。

### 2.4 自動化問題

證明系統 $\mathcal{P}$ 稱為**可自動化的**（automatable），如果存在算法 $A$ 和多項式 $p$ 使得：對任意永真式 $\varphi$，算法 $A$ 在時間 $p(|\varphi| + s_\mathcal{P}(\varphi))$ 內找到 $\varphi$ 的 $\mathcal{P}$-證明。

**定理 2.3**: 若 Extended Frege 系統是可自動化的，則 P = NP。

**證明思路**: Extended Frege 系統足夠強大，可以在多項式大小內證明所有永真式。若其可自動化，則可在多項式時間內解決 SAT 問題，導致 P = NP。 □

## 3. 一階邏輯的證明搜索

### 3.1 可判定性結果

**Church-Turing 定理**: 一階邏輯的有效性問題是**不可判定的**。

形式化地，不存在算法能對任意一階邏輯公式 $\varphi$ 判斷是否 $\models \varphi$。

### 3.2 半可判定性

儘管不可判定，一階邏輯有效性問題是**半可判定的**：

**定理 3.1**: 存在算法 $M$ 使得：
- 若 $\varphi$ 有效，則 $M(\varphi)$ 終止並輸出「有效」
- 若 $\varphi$ 無效，則 $M(\varphi)$ 可能永不終止

**證明**: 可通過枚舉所有可能的推理序列實現。由於一階邏輯的推理規則是可枚舉的，若 $\varphi$ 有效，則必然存在有限長度的證明，算法最終會找到。 □

### 3.3 複雜度界限

對於一階邏輯的有效片段，我們有以下複雜度結果：

**定理 3.2**: 
1. 一階邏輯的**可滿足性問題**在一般情況下需要**非元素階時間**（non-elementary time）
2. 存在**k-EXPSPACE-hard** 的一階邏輯片段，對任意固定的 $k$

**證明思路**: 通過歸約各種高複雜度問題（如 Presburger 算術、某些模態邏輯等）到一階邏輯片段。 □

## 4. 證明複雜度（Proof Complexity）視角

### 4.1 基本定義

**證明複雜度**研究在各種證明系統中，證明的最小長度如何隨輸入大小增長。

對證明系統 $\mathcal{P}$ 和永真式 $\varphi$，定義：
- **證明長度**: $s_\mathcal{P}(\varphi) = \min\{|\pi| : \mathcal{P} \vdash_\pi \varphi\}$
- **證明系統的強度**: 系統是否能為所有永真式提供多項式大小的證明

### 4.2 基本開放問題

**核心問題**: 是否存在多項式有界的命題證明系統？

形式化地：是否存在證明系統 $\mathcal{P}$ 和多項式 $p$ 使得對所有 $n$ 變量的永真式 $\varphi$，都有 $s_\mathcal{P}(\varphi) \leq p(n)$？

**定理 4.1**: 存在多項式有界的命題證明系統當且僅當 NP = coNP。

**證明思路**: 
- ($\Rightarrow$) 若存在多項式有界系統，則可在多項式時間內證明永真式，從而 coNP ⊆ P ⊆ NP
- ($\Leftarrow$) 若 NP = coNP，則存在多項式時間的永真性判定算法，可構造相應的證明系統 □

### 4.3 分離結果

**定理 4.2**: 存在永真式家族將以下證明系統分離：

$$\text{Resolution} \subsetneq \text{Cutting Planes} \subsetneq \text{Frege} \subseteq \text{Extended Frege}$$

每個分離都是指數級的，即存在在較弱系統中需要指數長度證明但在較強系統中有多項式長度證明的永真式。

### 4.4 下界技術

證明複雜度中的主要下界技術包括：

1. **插值法** (Interpolation): 通過構造插值函數證明某些永真式需要大證明
2. **隨機限制** (Random Restrictions): 針對 Resolution 等系統的下界
3. **代數方法**: 使用多項式方法分析代數證明系統
4. **通訊複雜度**: 將證明長度與通訊複雜度聯繫起來

**定理 4.3** (Haken): 存在 $n$ 變量永真式家族 $\{PHP_n\}$（鴿笼原理），使得任何 Resolution 證明的長度至少為 $2^{\Omega(n)}$。

## 5. 總結

### 5.1 複雜度階層

```
證明檢查：         P（線性到多項式時間）
    ↓
命題邏輯證明搜索：   coNP-complete
    ↓  
一階邏輯證明搜索：   不可判定（半可判定）
    ↓
高階邏輯證明搜索：   不可判定（更高的算術階層）
```

### 5.2 理論與實踐的差距

雖然理論上證明搜索是困難的，但在實踐中：

1. **SAT求解器**: 現代 CDCL 算法在許多實際例子上表現良好
2. **SMT求解器**: 結合多種判決過程處理特定理論
3. **交互式證明助理**: 通過人機交互克服自動化限制
4. **啟發式方法**: 雖然無法保證，但在特定領域有效

### 5.3 開放問題

1. **P vs NP**: 與證明複雜度的核心問題直接相關
2. **自動化界限**: 確定哪些證明系統可以自動化
3. **實用算法**: 設計在平均情況下高效的證明搜索算法
4. **新的下界技術**: 發展更強的數學工具證明下界

## 參考文獻

1. MathOverflow: [Algorithmic complexity of formal proof verification](https://mathoverflow.net/questions/226966/algorithmic-complexity-of-formal-proof-verification)
2. Wikipedia: [Proof complexity](https://en.wikipedia.org/wiki/Proof_complexity)
3. CS Theory StackExchange: [NP-completeness of proofs of length n](https://cstheory.stackexchange.com/questions/28037/looking-for-reference-on-np-completeness-of-proofs-of-length-n)
4. Wikipedia: [First-order logic](https://en.wikipedia.org/wiki/First-order_logic)
5. Krajíček, J. (1995). *Bounded Arithmetic, Propositional Logic and Complexity Theory*. Cambridge University Press.
6. Cook, S. A., & Reckhow, R. A. (1979). The relative efficiency of propositional proof systems. *The Journal of Symbolic Logic*, 44(1), 36-50.
7. Pudlák, P. (1998). The lengths of proofs. *Handbook of proof theory*, 2, 547-637.

---

*本文檔提供了數學證明運行複雜度的嚴格分析，涵蓋了從基本概念到前沿研究的各個層面。這些結果揭示了「證明檢查」與「證明搜尋」在計算複雜度上的根本差異，也正是計算邏輯與理論計算機科學中的核心研究領域。*